package astparser

import (
	"backend/internal/lib/utils"
	"regexp"

	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"log"
	"os"
	"strings"

	"gopkg.in/yaml.v3"
)

type Flags struct {
	in   *string
	out  *string
	meta *string
	pkg  *string
}

func parseFlags() (*Flags, error) {
	// Parse program arguments
	var flags Flags
	flags.in = flag.String("in", "", "input go file")
	flags.out = flag.String("out", "", "output go file")
	flags.meta = flag.String("meta", "", "metadata yaml")
	flags.pkg = flag.String("pkg", "schemas", "name of the package")
	flag.Parse()
	if *flags.in == "" || *flags.meta == "" || *flags.out == "" {
		return &flags, errors.New("usage: taggen -in <raw.go> -meta <metadata.yaml> -out <output.go>")
	}
	return &flags, nil
}

type FieldMeta struct {
	Type          string `yaml:"type"`
	JSON          string `yaml:"json"`
	BSON          string `yaml:"bson"`
	Validate      string `yaml:"validate"`
	Description   string `yaml:"description"`
	Default       string `yaml:"default"`
	Example       string `yaml:"example"`
	FilterExample string `yaml:"filter-example"`
	SwaggerIgnore string `yaml:"swaggerignore"`
}

type Config struct {
	Imports     []string             `yaml:"imports"`
	Fields      map[string]FieldMeta `yaml:"fields"`
	Selectables []string             `yaml:"selectables"`
	Sortables   []string             `yaml:"sortables"`
}

func parseYaml(flags *Flags) (Config, error) {
	// parse the yaml file
	var config Config
	metaData, err := os.ReadFile(*flags.meta)
	if err != nil {
		return config, err
	}
	err = yaml.Unmarshal(metaData, &config)
	if err != nil {
		return config, err
	}

	sortables := make([]string, 0, len(config.Sortables)*2)
	for _, field := range config.Sortables {
		sortables = append(sortables, field)
		sortables = append(sortables, "-"+field)
	}
	config.Sortables = sortables
	return config, err
}

func getFileBuilder(
	flags *Flags,
) (*ast.File, *token.FileSet, *strings.Builder, error) {
	var fileBuilder strings.Builder

	// Parse the raw go file
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, *flags.in, nil, parser.ParseComments)
	if err != nil {
		return node, fset, &fileBuilder, err
	}

	fileBuilder.WriteString("// Code generated by go generate; DO NOT EDIT.\n")
	fileBuilder.WriteString("package " + *flags.pkg + "\n\n")
	return node, fset, &fileBuilder, nil
}

func addImports(
	node *ast.File, config Config, fileBuilder *strings.Builder,
) error {
	var fileImports []string
	for _, imp := range node.Imports {
		fileImports = append(fileImports, imp.Path.Value)
	}

	var configImports []string
	for _, imp := range config.Imports {
		configImports = append(configImports, "\""+imp+"\"")
	}

	allImports := utils.MergeUnique(fileImports, configImports)
	if len(allImports) == 0 {
		return nil
	}

	fileBuilder.WriteString("import (\n")
	for _, imp := range allImports {
		fileBuilder.WriteString("\t" + imp + "\n")
	}
	fileBuilder.WriteString(")\n\n")
	return nil
}

type SchemasCommand string

const (
	TagCmd     SchemasCommand = "tag"
	FiltersCmd SchemasCommand = "filters"
)

type StructParsingOptions struct {
	cmd       SchemasCommand
	allownil  bool
	multipart bool
}

func parseOptions(group *ast.CommentGroup) *StructParsingOptions {
	const SchemasPrefix = "schemas:"

	if group == nil {
		return nil
	}

	text := strings.TrimSpace(group.Text())
	if !strings.HasPrefix(text, string(SchemasPrefix)) {
		return nil
	}

	// extract command
	cmdString := strings.TrimSpace(strings.TrimPrefix(text, string(SchemasPrefix)))
	re := regexp.MustCompile(`^([^\s]+)`)
	match := re.FindStringSubmatch(cmdString)
	if len(match) < 2 {
		return nil
	}
	cmd := SchemasCommand(match[1])
	if cmd != TagCmd && cmd != FiltersCmd {
		return nil
	}

	// Check if we allownil
	allownil := strings.Contains(cmdString, "allownil")

	// Check if multipart
	multipart := strings.Contains(cmdString, "multipart")

	return &StructParsingOptions{cmd: cmd, allownil: allownil, multipart: multipart}
}

func iterateOverDeclarations(
	node *ast.File,
	fset *token.FileSet,
	config Config,
	fileBuilder *strings.Builder,
) error {
	for _, decl := range node.Decls {
		switch d := decl.(type) {
		case *ast.GenDecl:
			switch d.Tok {
			case token.IMPORT:
				// Imports were already handled
				continue
			case token.CONST, token.VAR:
				fileBuilder.WriteString(nodeToGoCode(decl, fset) + "\n")
			case token.TYPE:
				options := parseOptions(d.Doc)
				if options == nil {
					fileBuilder.WriteString(nodeToGoCode(decl, fset) + "\n")
				} else {
					if len(d.Specs) > 1 {
						return errors.New("schemas directive should not be used with block of structs definition")
					}
					typeSpec := d.Specs[0].(*ast.TypeSpec)
					structType, ok := typeSpec.Type.(*ast.StructType)
					if !ok {
						return errors.New("schemas directive should be used with structs only")
					}
					err := writeStruct(structType, typeSpec.Name.Name, options, config, fileBuilder)
					if err != nil {
						return err
					}
				}
			}

		case *ast.FuncDecl:
			fileBuilder.WriteString(nodeToGoCode(decl, fset) + "\n")
		}
	}
	return nil
}

func nodeToGoCode(node ast.Node, fset *token.FileSet) string {
	var buf strings.Builder
	printer.Fprint(&buf, fset, node)
	return buf.String()
}

type FieldTransformer struct {
	field       *ast.Field
	name        string
	targetTag   string
	omitempty   bool
	jsonName    string
	annotations map[string]string
	meta        *FieldMeta
	comment     string
	mode        SchemasCommand
	isNullable  bool
	isMultipart bool
	typeStr     string
}

func (ft *FieldTransformer) readName() error {
	if len(ft.field.Names) > 1 {
		return errors.New("cannot annoatate more than one field per line")
	}
	if len(ft.field.Names) == 0 {
		// Embdeded struct -> do nothing
		return nil
	}

	ft.name = ft.field.Names[0].Name
	return nil
}

func (ft *FieldTransformer) wrongTagFormat(tag string) error {
	return fmt.Errorf("wrong tag format for field %s. Expected key:\"val\" or key:\"val1,val2\". Received: %s", ft.name, tag)
}

func (ft *FieldTransformer) readSpecialTag(tag string) error {
	// example value: number,json=num,omitempty
	if tag == "" {
		return ft.wrongTagFormat(tag)
	}
	tag = strings.Trim(tag, "\"")

	// extract targetTag
	re := regexp.MustCompile(`^([^,]+)`)
	match := re.FindStringSubmatch(tag)
	if len(match) > 1 {
		ft.targetTag = strings.Trim(match[1], `"`)
	} else {
		return ft.wrongTagFormat(tag)
	}

	// Check omitempty presence
	ft.omitempty = strings.Contains(tag, "omitempty")

	// Check json presence
	re = regexp.MustCompile(`json=([^,]+)`)
	match = re.FindStringSubmatch(tag)
	if len(match) > 1 {
		ft.jsonName = match[1]
	}

	return nil
}

func (ft *FieldTransformer) readTag() (bool, error) {
	// Return false, nil if no tag
	// Return false, err if an error encountered
	// Return true, nil if the tag was read successfully

	ft.annotations = make(map[string]string)
	if ft.field.Tag == nil {
		return false, nil
	}

	rawStr := strings.Trim(ft.field.Tag.Value, "`")
	for tagStr := range strings.SplitSeq(rawStr, " ") {
		if tagStr == "" {
			continue
		}

		parts := strings.SplitN(tagStr, ":", 2)
		if len(parts) != 2 {
			return false, ft.wrongTagFormat(tagStr)
		}

		if parts[0] == "tag" {
			if err := ft.readSpecialTag(parts[1]); err != nil {
				return false, err
			}
		} else {
			ft.annotations[parts[0]] = strings.Trim(parts[1], "\"")
		}
	}

	return true, nil
}

func (ft *FieldTransformer) readConfig(config Config) error {
	meta, exists := config.Fields[ft.targetTag]
	if !exists {
		return fmt.Errorf("no config for field(s) %s", ft.name)
	}
	ft.meta = &meta
	ft.comment = meta.Description
	return nil
}

func (ft *FieldTransformer) readStructOptions(options *StructParsingOptions) error {
	if options.cmd != TagCmd && options.cmd != FiltersCmd {
		return fmt.Errorf("unknown schemas command %s", options.cmd)
	}
	ft.mode = options.cmd

	if options.allownil {
		ft.isNullable = true
	} else {
		ft.isNullable = false
	}

	if options.multipart {
		ft.isMultipart = true
	} else {
		ft.isMultipart = false
	}

	return nil
}

func (ft *FieldTransformer) readExpressionType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.ArrayType:
		return "[]" + ft.readExpressionType(t.Elt)
	case *ast.StarExpr:
		return "*" + ft.readExpressionType(t.X)
	case *ast.InterfaceType:
		return "any"
	default:
		return "any"
	}
}

func (ft *FieldTransformer) readType() error {
	if ft.mode == FiltersCmd {
		ft.typeStr = "[]string"
	} else {
		ft.typeStr = ft.readExpressionType(ft.field.Type)
		if ft.typeStr == "any" && ft.meta.Type != "" {
			ft.typeStr = ft.meta.Type
		}
		if ft.isNullable && !strings.HasPrefix(ft.typeStr, "*") {
			// If nullable then use pointer as type
			ft.typeStr = "*" + ft.typeStr
		}
	}
	return nil
}

func (ft *FieldTransformer) syncSchemasAnnotations() {
	// JSON tag
	if ft.jsonName != "" {
		ft.annotations["json"] = strings.TrimSpace(ft.jsonName)
	} else if ft.meta.JSON != "" {
		ft.annotations["json"] = strings.TrimSpace(ft.meta.JSON)
	} else {
		ft.annotations["json"] = ft.targetTag
	}

	// Form tag
	if ft.isMultipart {
		ft.annotations["form"] = ft.annotations["json"]
	}

	// BSON tag
	if ft.meta.BSON != "" {
		ft.annotations["bson"] = strings.TrimSpace(ft.meta.BSON)
	} else {
		ft.annotations["bson"] = ft.annotations["json"]
	}

	// Validate tag
	validate := ""
	if ft.omitempty || ft.isNullable {
		validate = "omitempty"
	}
	if ft.meta.Validate != "" {
		validate = validate + "," + ft.meta.Validate
	}
	if validate != "" {
		ft.annotations["validate"] = strings.Trim(validate, ",")
	}

	// Example tag
	if ft.meta.Example != "" {
		ft.annotations["example"] = ft.meta.Example
	}

	// SwaggerIgnore
	if ft.meta.SwaggerIgnore == "true" {
		ft.annotations["swaggerignore"] = "true"
	}
}

func (ft *FieldTransformer) syncFiltersAnnotations() {
	// JSON tag
	if ft.jsonName != "" {
		ft.annotations["json"] = strings.TrimSpace(ft.jsonName)
	} else if ft.meta.JSON != "" {
		ft.annotations["json"] = strings.TrimSpace(ft.meta.JSON)
	} else {
		ft.annotations["json"] = ft.targetTag
	}

	// Form Tag
	ft.annotations["form"] = ft.annotations["json"]
	ft.annotations["collectionFormat"] = "multi"

	// Filter tag
	filter := ft.meta.Type
	if ft.meta.Validate != "" {
		filter = filter + "," + ft.meta.Validate
	}
	if filter != "" {
		ft.annotations["filter"] = strings.Trim(filter, ",")
	}

	// Example tag
	if ft.meta.FilterExample != "" {
		ft.annotations["example"] = ft.meta.FilterExample
	} else if ft.meta.Example != "" {
		ft.annotations["example"] = ft.meta.Example
	}
}

func (ft *FieldTransformer) AnnotationString() string {
	var parts []string
	skipExample := false
	usedTags := []string{"json", "form", "filter", "validate", "default", "example", "bson", "swaggerignore", "collectionFormat"}

	for _, t := range usedTags {
		if t == "example" && skipExample {
			continue
		}

		val, exists := ft.annotations[t]
		if exists {
			parts = append(parts, fmt.Sprintf("%s:\"%s\"", t, val))
		}

		if t == "default" && exists {
			// No point of adding example if we have a default value
			skipExample = true
		}
	}

	merged := strings.Join(parts, " ")
	if merged == "" {
		return ""
	}
	return "`" + merged + "`"
}

func (ft *FieldTransformer) String() string {
	result := ft.name + " " + ft.typeStr
	annotations := ft.AnnotationString()
	if annotations != "" {
		result = result + " " + annotations
	}
	if ft.comment != "" {
		result = result + " // " + ft.comment
	}
	return strings.TrimSpace(result)
}

func newFieldTransformer(field *ast.Field, options *StructParsingOptions, config Config) (FieldTransformer, error) {
	ft := FieldTransformer{field: field}

	// Step 1: Reading the field name
	if err := ft.readName(); err != nil {
		return ft, err
	}

	// Step 2: reading the field tags
	tagFound, err := ft.readTag()
	if !tagFound {
		// read the type and return
		ft.typeStr = ft.readExpressionType(ft.field.Type)
		return ft, nil
	} else if err != nil {
		return ft, err
	}

	// Step 3: reading the config
	if err := ft.readConfig(config); err != nil {
		return ft, err
	}

	// Step 4: reading the struct options
	if err := ft.readStructOptions(options); err != nil {
		return ft, err
	}

	// Step 5: reading the type
	if err := ft.readType(); err != nil {
		return ft, err
	}

	// Step 6: sync the annotations
	if ft.mode == FiltersCmd {
		ft.syncFiltersAnnotations()
	} else {
		ft.syncSchemasAnnotations()
	}

	return ft, nil
}

func writeAnnotatedStruct(
	structType *ast.StructType,
	name string,
	options *StructParsingOptions,
	config Config,
	fileBuilder *strings.Builder,
) error {
	fileBuilder.WriteString("\ntype " + name + " struct {\n")

	for _, field := range structType.Fields.List {
		ft, err := newFieldTransformer(field, options, config)
		if err != nil {
			return err
		}
		fileBuilder.WriteString(ft.String() + "\n")
	}
	fileBuilder.WriteString("}\n\n")
	return nil
}

func writeFiltersStruct(
	structType *ast.StructType,
	name string,
	options *StructParsingOptions,
	config Config,
	fileBuilder *strings.Builder,
) error {
	// Write struct heade
	fileBuilder.WriteString("\ntype " + name + " struct {\n")

	// Write Page field
	fileBuilder.WriteString("\tPage\tint\t`json:\"page\" default:\"1\"`\n")

	// Write Size field
	fileBuilder.WriteString("\tSize\tint\t`json:\"size\" default:\"100\"`\n")

	// Write Sort field
	sortOptions := strings.Join(config.Sortables, " ")
	sortLine := fmt.Sprintf("Sort []string `json:\"sort\" validate:\"dive,oneof=%s\" example:\"%s\"`", sortOptions, config.Sortables[0])
	fileBuilder.WriteString("\t" + sortLine + "\n")

	// Write Fields field
	fieldsOptions := strings.Join(config.Selectables, " ")
	fieldsLine := fmt.Sprintf("Fields []string `json:\"fields\" validate:\"dive,oneof=%s\" example:\"%s,%s\"`", fieldsOptions, config.Selectables[0], config.Selectables[1])
	fileBuilder.WriteString("\t" + fieldsLine + "\n")

	// Write the field filters
	for _, field := range structType.Fields.List {
		ft, err := newFieldTransformer(field, options, config)
		if err != nil {
			return err
		}
		fileBuilder.WriteString(ft.String() + "\n")
	}

	// Write struct tail
	fileBuilder.WriteString("}\n\n")

	return nil
}

func writeStruct(
	typeSpec *ast.StructType,
	name string,
	options *StructParsingOptions,
	config Config,
	fileBuilder *strings.Builder,
) error {
	var err error

	switch options.cmd {
	case TagCmd:
		err = writeAnnotatedStruct(typeSpec, name, options, config, fileBuilder)
	case FiltersCmd:
		err = writeFiltersStruct(typeSpec, name, options, config, fileBuilder)
	default:
		err = fmt.Errorf("invalid schemas command: %s", options.cmd)
	}
	return err
}

func ParseSchemaFile() {
	// Step 1: parse arguments
	flags, err := parseFlags()
	if err != nil {
		log.Fatal(err.Error())
	}

	// Step 2: parsing yaml data
	config, err := parseYaml(flags)
	if err != nil {
		log.Fatal(err.Error())
	}

	// Step 3: parsing go file
	node, fset, fileBuilder, err := getFileBuilder(flags)
	if err != nil {
		log.Fatal(err.Error())
	}

	// Step 4: Add imports
	err = addImports(node, config, fileBuilder)
	if err != nil {
		log.Fatal(err.Error())
	}

	// Step 5: Iterate over declarations
	err = iterateOverDeclarations(node, fset, config, fileBuilder)
	if err != nil {
		log.Fatalf("Warning: formatting failed: %v", err)
	}

	// Step 6: Parsing the generated go code
	formatted, err := format.Source([]byte(fileBuilder.String()))
	if err != nil {
		log.Fatalf("Warning: formatting failed: %v", err)
	}

	// Step 7: Writing the annotaed go file
	if err := os.WriteFile(*flags.out, formatted, 0644); err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Generated %s successfully!\n", *flags.out)
}
